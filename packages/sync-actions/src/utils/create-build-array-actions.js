const REGEX_NUMBER = new RegExp(/^\d+$/)
const REGEX_UNDERSCORE_NUMBER = new RegExp(/^_\d+$/)

export const ADD_ACTIONS = 'create'
export const REMOVE_ACTIONS = 'remove'
export const CHANGE_ACTIONS = 'change'

/**
 * Tests a delta to see if it represents a create action.
 * eg. delta:
 * {
 *   0: [ { foo: 'bar' } ]
 * }
 *
 * @param  {object}  obj The delta generated by the diffpatcher
 * @param  {string}  key key of generated delta to examine
 * @return {Boolean}     Returns true if delta represents a create action,
 *   false otherwise
 */
function isCreateAction(obj, key) {
  return (
    REGEX_NUMBER.test(key) && Array.isArray(obj[key]) && obj[key].length === 1
  )
}

/**
 * Tests a delta to see if it represents a change action.
 * eg. delta:
 *
 * {
 *   0: {
 *     foo: ['bar', 'baz']
 *   }
 * }
 * @param  {object}  obj The delta generated by the diffpatcher
 * @param  {string}  key key of generated delta to examine
 * @return {Boolean}     Returns true if delta represents a change action,
 *   false otherwise
 */
function isChangeAction(obj, key) {
  return (
    REGEX_NUMBER.test(key) &&
    (typeof obj[key] === 'object' || typeof obj[key] === 'string')
  )
}

/**
 * Tests a delta to see if it represents a remove action.
 * eg. delta:
 *
 * {
 *   _0: [ 'foo', 0, 0 ]
 * }
 * @param  {object}  obj The delta generated by the diffpatcher
 * @param  {string}  key key of generated delta to examine
 * @return {Boolean}     Returns true if delta represents a remove action,
 *   false otherwise
 */
function isRemoveAction(obj, key) {
  return (
    REGEX_UNDERSCORE_NUMBER.test(key) &&
    Array.isArray(obj[key]) &&
    obj[key].length === 3 &&
    (typeof obj[key][0] === 'object' || typeof obj[key][0] === 'string') &&
    obj[key][1] === 0 &&
    obj[key][2] === 0
  )
}

/**
 * Generate + configure a function to build actions for nested objects
 * @param  {string} key    key of the attribute containing the array of
 *   nested objects
 * @param  {object} config configuration object that can contain the keys
 *   [ADD_ACTIONS, REMOVE_ACTIONS, CHANGE_ACTIONS], each of
 *   which is a function. The function should accept the old + new arrays and
 *   return an action object.
 * @return {Array}        The generated array of actions
 */
export default function createBuildArrayActions(key, config) {
  return function buildArrayActions(diff, oldObj, newObj) {
    const addActions = []
    const removeActions = []
    const changeActions = []

    if (diff[key]) {
      const arrayDelta = diff[key]

      Object.keys(arrayDelta).forEach((index) => {
        if (config[ADD_ACTIONS] && isCreateAction(arrayDelta, index)) {
          const actionGenerator = config[ADD_ACTIONS]
          // When adding a new element you don't need the oldObj
          const action = actionGenerator(
            newObj[key][index],
            parseInt(index, 10)
          )

          if (action) addActions.push(action)
        } else if (
          config[CHANGE_ACTIONS] &&
          isChangeAction(arrayDelta, index)
        ) {
          const actionGenerator = config[CHANGE_ACTIONS]
          // When changing an existing element you need both old + new
          const action = actionGenerator(
            oldObj[key][index],
            newObj[key][index],
            parseInt(index, 10)
          )

          if (action) changeActions.push(action)
        } else if (
          config[REMOVE_ACTIONS] &&
          isRemoveAction(arrayDelta, index)
        ) {
          const realIndex = index.replace('_', '')
          const actionGenerator = config[REMOVE_ACTIONS]
          // When removing an existing element you don't need the newObj
          const action = actionGenerator(
            oldObj[key][realIndex],
            parseInt(realIndex, 10)
          )

          if (action) removeActions.push(action)
        }
      })
    }

    return changeActions.concat(removeActions, addActions)
  }
}
